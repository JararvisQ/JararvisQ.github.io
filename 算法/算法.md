# 分治，回溯 - 递归
- 本质还是递归 - 最近重复性。

## 递归误区
- 抵制人肉递归
- 找重复子问题
- 数学归纳法, 当最简单的N成立,证明N + 1也成立,所以之后的结果也成立.

# 回溯
- 仍旧用递归的方法实现，反复重复之前步骤可能出现的两种情况：
  - 找到一个可能存在的正确答案。
  - 尝试了所有方法，最后宣告没有答案。

# 计算机操作
- if else, for, recursion
- 找最近 重复子问题

# 贪心 - 最优
- 每一步都选择当前状态下最好最优，导致某些情况下全局最好或者最优。
- 高效。但由于局限性，一般不能用来得到所需要的答案。可以用来解决一些要求不是很明确的问题。

## 与动态规划不同：
- 贪心会对于每个子问题都做出选择，不能回退（回溯）。
- 动态规划会保存以前的运算结果，根据以前结果进行选择，有回退功能。（最优判断 + 回退）

## 适用的场景
1. 问题能分为多个子问题来解决。
2. 子问题的最优解能递推到最终问题的最优解。（最优子结构）

# 二分查找

## 前提
- 目标函数的单调性（单调递增或递减）
- 存在上下界
- 能通过索引访问

# 动态规划（dynamic programming） - 求最优解

## 定义：
- 复杂的问题定义可以分解成多个简单的子问题，从而找到最优解。（通过递归的方式）
- 重点：分治 + 最优子结构

## 和分治的区别
- DP找的是最优解「存储于缓存里」，中途淘汰掉次优解。

## 关键点 - 思路
1. 最优子结构：opt[n] = best_of(opt[n-1], opt[n-2], ...)
2. 存储中间状态：opt[i] ⭐
3. 递推公式：状态转移方程，DP方程
  - fib: opt[i] = opt[n - 1] + opt[n - 2]
  - 二维路径：opt[i, j] = opt[i + 1][j] + opt[i][j + 1] // 同时需要判定a[i, j]是否为特殊情况

## 步骤
- 复杂问题转化为一个简单的子问题
- 猜递推方程
- 合并子问题的解merge
- 递推，记忆化（建立状态表）自底向上递推
- 解决

