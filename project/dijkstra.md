# dijkstra(迪杰斯特拉)
- 最短路径算法，用于计算一个节点到其他节点的最短路径。
- 它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。

## 具体
1. 需要指定起点A
2. 引入两个Map：
  - S（记录已求出最短路径的顶点）以及相应的最短路径长度;
  - U 则是记录未求出的最短路径顶点（到达起点的最短距离）。
3. 初始：如果s和v不相邻，则距离为`infinity`
  1. S中只有起点s，U中是除了S之外的其他顶点，并且U中顶点路径是起点S到顶点的路径。
  2. 然后，`不考虑S`，从U找出路径最短的顶点，加入到S中；
  3. 更新U中顶点和顶点对应的路径；

![](/image/a51ad8f8311f402a0b1521f53b16728.png)

1. 初始化：
  ```JS
  {D(0)，C(3)，E（4），F（*），G（*），B（*），A(*)}
  ```
2. 不考虑S，找到U中最短的，加入S，即:
  ```JS
  dis[c] = 3
  S = [ D, C ]
  ```
3. 找到 C 连接的点，E,F,B，不看S里存在的值；同时计算到与顶点D的距离,取最短的比较S里的值，如果更小则更新；反之则不管；
  ```JS
  dis[C-B] === 10
  dis[B] = dis[C - B] + dis[C - D] = 13
  dis[E] = dis[E - C - D] = 8
  dis[E - C - D] > dis[E - D] // 不更新
  S: S = {D，C}
  U：{D(0)，C(3)，E（4），F（9），G（*），B（13），A(*)}
  // 
  S: S = {D，C，E}
  U: {D(0)，C(3)，E（4），F（6），G（12），B（13），A(*)}
  // 
  S: S = {D，C，E，F}
  U: {D(0)，C(3)，E（4），F（6），G（12），B（13），A(22)}.
  // 
  S: S = {D，C，E，F，G}
  U: {D(0)，C(3)，E（4），F（6），G（12），B（13），A(22)}.
  // 
  S: S = {D，C，E，F，G，B}
  U: {D(0)，C(3)，E（4），F（6），G（12），B（13），A(22)}.
  // 
  S: S = {D，C，E，F，G，B，A}
  U: {D(0)，C(3)，E（4），F（6），G（12），B（13），A(22)}.
  ```
