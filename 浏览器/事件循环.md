# 事件循环 （执行效率和实时性的权衡）

## 内部实现
1. 主线程的任务会被按顺序依次执行，任务执行完后，线程会自动退出。

2. 想要线程运行过程中，「接受新的任务」。采用了事件循环机制。
  
    - 循环。线程语句最后新增一个for循环语句，且循环会一直执行。
    - 事件。如果其他线程插入，例如：用户输入。主线程会处于等待状态，执行结束后，线程会被激活。

3. 但是，所有的任务都来自线程内部，另外线程想让主线程执行一个任务。如下图：主线程通过IPC接收到IO线程的任务后，就需要对其进行处理。 --- 「消息队列」。
    - 同时多个线程操作同一个消息队列，在添加和取出任务时需要加上一个同步锁。

![](https://static001.geekbang.org/resource/image/2e/05/2eb6a8ecb7cb528da4663573d74eb305.png)

4. 如何处理高优先级问题？例如：DOM操作频繁，同步会导致执行效率下降，异步会影响实时性。「宏任务&微任务」 --- 每个宏任务下都包含一个微任务队列，如DOM发生了变化，就会将变化添加到微任务中，在宏任务执行完后，会将微任务队列里的任务执行完再执行下一个宏任务。

5. 单个任务执行时间过久？会造成页面卡顿现象，通过回调功能实现。

6. 同时，在需要退出页面时，页面主线程会设置一个退出标志的变量。每一个任务执行完了后，都会判读是否有设置退出标志。

## 事件循环&消息队列图
![](https://static001.geekbang.org/resource/image/e2/c6/e2582e980632fd2df5043f81a11461c6.png)

# setTimeout （hash map结构）

7. 定时器需要在指定的时间间隔内被调用，但消息队列里的任务是按先进先出的顺序进行的，不能直接添加到消息队列中。「维护一个需要延迟执行的任务列表（宏任务）」包括并不限于定时器。

8. 设置定时器的回调函数时，渲染进程会创建一个回调任务，包含发起时间和延迟执行时间，之后添加到延迟执行队列中。

9. 如何执行：
```C++

void ProcessTimerTask(){
  //从delayed_incoming_queue中取出已经到期的定时器任务
  //依次执行这些任务
}

TaskQueue task_queue；
void ProcessTask();
bool keep_running = true;
void MainTherad(){
  for(;;){
    //执行消息队列中的任务
    Task task = task_queue.takeTask();
    ProcessTask(task);
    
    //执行延迟队列中的任务
    ProcessDelayTask()

    if(!keep_running) //如果设置了退出标志，那么直接退出线程循环
        break; 
  }
}
```

10. 清除定时器时，传入定时器的ID可以直接在延迟hash表中将其删除。

11. 缺陷：
    - 延迟任务会在当前任务执行完之后去执行。当任务执行时间过久，会影响定时器执行。
    - 定时器嵌套调用，会设置最短间隔为4毫秒。 --- 实时性高的动画不适合定时器实现。
      - requestAnimationFrame，会去根据系统刷新的节奏调用相应的任务，但也是需要在主线程任务执行后在去执行。
    - 未激活的页面，定时器最小间隔为1000毫秒。
    - 延迟时间有最大值，超过后立即执行。
    - this指向window

# XMLHTTPRequest

- XMLHTTPRequest流程：

  1. 新建XMLHTTPRequest对象。
  2. 注册相关事件回调处理。
  3. 初始化请求。
  ```JS
  xhr.open('Get', URL, true)
   ```
  4. 配置请求参数。
  5. 发送请求。

- 浏览器的角度看请求：浏览器通过XMLHTTPRequest发起请求，会交与网络进程这些其他进程去执行，然后执行结果在通过IPC方式通知渲染进程，之后渲染进程在将消息添加到消息队列中。
![](https://static001.geekbang.org/resource/image/29/c6/2914a052f4f249a52077692a22ee5cc6.png)

# 宏任务，微任务

- 宏任务执行

  - 先从多个消息队列中选出一个最老的任务
  - 记录开始执行时间，将oldestTask设置为正在执行的任务
  - 执行完后，删除该任务
  - 统记执行完成的时长

- 异步回调的形式
  - 一种是将其做成一个任务放在「消息队列尾部」。定时器
  - 一种是直接添加在「微任务尾部」。MutationObserver，Promise.resolve

- 微任务的执行：
  - 当前的宏任务的JS引擎快退出全局执行上下文并清空调用栈时，JS引擎会检查全局执行上下文中的微任务，然后按照顺序执行队列中的微任务。「检查点」
  - 如果在执行微任务中产生了新的微任务，会推入到当前的微任务队列中，直到当前微任务队列执行完。
  - 会延长宏任务的执行时间，宏任务执行时间 += 微任务执行时间

- MutationObserver，采用「观察者模式」来监听DOM变化，属性的变化，节点的增减，内容的变化。会多次DOM变化后，「一次性」触发异步调用。

- 通过异步解决同步操作的「性能问题」，微任务解决「实时性」问题。

# Promise

- 目的：解决异步编程风格问题

  - 代码逻辑不连续性。需要立即绑定回调函数，实现了对回调函数的延时绑定。
  - 嵌套调用。then会去依据promise层级递归查找出promise的resolve，并依次传回最外层。reject同理。
  - then的微任务机制。由于延迟绑定函数的原因，.then需要在立即执行函数之后调用。如果处理成宏任务的话，中间可能会有别的宏任务插入，保证不了实时性。
