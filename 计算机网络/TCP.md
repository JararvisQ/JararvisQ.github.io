# 1. 与UDP的区别

- 有状态。面向链接。三次握手建立链接过程。
- 可靠性。
  - 发送给谁，有没有被接收到，顺序到达。
  - 网络不佳时会调整行为，控制发送速度或者重发。
- 字节流。
  - UDP是基于数据包，是分散的小数据包，顺序发，乱序收。
  - TCP为了维护状态，将一个个IP包变成字节流。

- 总结：UDP，不可靠，无状态，基于数据报。

# 2. 三次握手
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/23/170723de9b8aa08b~tplv-t2oaga2asx-watermark.awebp)
- 双方都是「close」状态，服务器开始监听某个端口，进入「listen」状态。
- 客户端发送「SYN」到服务器，变成「SYN-SEND」
- 服务端接受到后，返回「SYN和ACK」,变成「SYN-REVD」。
- 客户端发送「ACK」到服务器，变成「建立」状态。服务端收到后也是进入「建立」状态。

## 为什么不是两次？
- 无法确认客户端的接受能力。如果由于网络原因，客户端重传，再客户端断开后，服务端收到第一个的请求，又需要建立链接。

## 可以携带数据嘛？
- 等建立状态时候可以，不然在握手过程中如果客户端发送很大的数据，会给服务器造成风险。

- 总结：凡是需要对端确认的，一定消耗TCP报文的序列号。

# 4. 四次挥手
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/23/170723e5c0e05829~tplv-t2oaga2asx-watermark.awebp)

- 开始两边都处于「建立」状态。
- 客户端要断开，发给服务器「FIN」报文。并变成「FIN-WAIT-1」状态。这时，客户端变成半关闭状态，「无法向服务端发送报文」，只能接受。
- 服务端接收后向客户端确认，变成「CLOSED-WAIT」状态。
- 客户端接受到「确认」后，变成「FIN-WAIT2」状态。
- 随后，服务端向客户端发送「FIN,ACK」，自己进入「LAST-ACK」状态。
- 客户端接受到后，变成「TIME-WAIT」状态，发送「ACK」给服务器。
- 这时，客户端需要等待2个MSL（报文最大生成时间），如果这段时间内，客户端没有收到服务端发来的消息，标识「ACK」成功到达，挥手结束，如果没有则重发。

## 等待2MSL？
- 2个包括服务端接受不到关闭方最后的「ACK」的重传问题。

## 为何4次不是3次？ - `发送了FIN之后不能发送数据`
- 服务端需要等到所有报文都返回给到客户端才发送「FIN」。
- 如果是3次，会导致客户端以为是服务端接受不到，而重传。

# 5. 三次握手优化（TFO - TCP Fast Open）
- 在握手阶段服务端在回复「SYN-ACK」时，顺便计算一个「SYN cookie」。同样返回给到客户端。
- 客户端拿到后继续完成三次握手。
- 在握手一次后，之后建立握手时，可以同时发送「SYN + Cookie + HTTP请求」。服务器会进行验证，如果验证通过后，会返回「SYN + ACK + HTTP响应」。
- 随后客户端再返回ACK。

# 6. TCP拥塞阻塞

## 队头阻塞
- TCP为了保证包有序到达，当有一个包丢失时，会等待丢失的包重传到达后，再合并向上交付

## 每条TCP链接都需要维护两个核心状态。
- 拥塞窗口。指自己还能传输的数据量大小。（发送端的限制，接收窗口是接收端的限制）
- 慢启动阈值。
  - 在开始传输的一段时间，发送端每收到一个 ACK，拥塞窗口大小加 1，也就是说，每经过一个 RTT，cwnd 翻倍。如果说初始窗口为 10，那么第一轮 10 个报文传完且发送端收到 ACK 后，cwnd 变为 20，第二轮变为 40，第三轮变为 80，依次类推。
  - 到达阈值后减低速度。

## 涉及到的算法
- 慢启动。
- 拥塞避免。到了阈值后，会降低为1 / cwnd。
  - 慢启动和拥塞避免是一体的。
- 快速重传。如果发生丢包，接收端会返回上一个包的ACK。不需要等到RTO时间才重传。
  - 选择性重传。有个区间段，发送端可以确认那些数据丢失了，进行选择性重传。
- 快速回复。发生了拥堵后，或者丢包，会「减低阈值」。