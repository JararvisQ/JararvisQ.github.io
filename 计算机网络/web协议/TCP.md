# 解决范围
- 不同网络，不同网络种类中的任意长度消息的可靠的，顺序传输。

# 解决了那些问题？
- TCP：面向链接的，可靠的，基于字节流的传输层通讯协议。
- 特点：
  - 点对点的（不能广播，多播），面向链接的
  - 双向传递，全双工（websocket）
  - 字节流：打包成报文段，保证有序接受，重复直接丢弃。（不强制必须离散创建数据块，不限制数据大小）
  - 流量缓存。
  - 可靠传输。丢包重发
  - 拥塞控制。

# TCP报文
- 源地址，目标地址。
- UDP头部：destination post目标端口。

## 如何标识一个链接 - TCP四元组
- 源地址，源端口，目的地址，目的端口

# 三次握手

## 为何要三次握手
- 同步Sequence序列号。初始序列号ISN，交换TCP通讯参数。协商MSS
- SYN同步帧，ACK确认帧。

## 流程：
- 客户端发送一个给到「SYN」服务器。
- 服务器收到后，返回一个「ACK+1 + 服务器的SYN」给客户端。
- 客户端返回确认的「ack」。

## 优化：cookie
- fast open 降低时延。第一次发送给服务器时，服务器回复时，生成一个cookie，保存链接的相关信息。在第二次开始，客户端可以直接发送「数据 + SYN + cookie」给到服务器。
- 一般是，收到客户端的ACK后，打开nginx应用程序。TCP_DEFER_ACCEPT优化成收到data后，才打开。

## 安全：
- SYN攻击。短时间内发送大量的SYN占满服务器的SYN队列。
- 解决：设置配置；tcp_syncookies，满了后直接返回cookie，客户端再次发送时，带上cookie并回复链接。

# 数据传输的MSS分段
- TCP会依据「MSS最大报文大小，流控（接收端能力）」对数据进行分层，避免IP层没有效率的分层。
- MSS: max segment size,tcp承载的最大数据量。

# 重传和确认 - 定时器

## 发展历史
- 第一次消息发送时会打开一个定时器，在定时器结束时收不到服务端回复时，进行重发。「必须等服务器回复时才发送其他消息」。PAR
- 每个消息加上标识，可以并发消息。「没有考虑到服务端的内存」
- 滑动窗口。

## 重传定时器如何设置 - RTO
- RTO设置略大于RTT

# 滑动窗口 - 发送大小
- 发送窗口：
  - 已发送并收到ACK
  - 已发送未收到ACK
  - 未发送并在可接受处理范围内（与上一次合称发送窗口）
  - 未发送且超出处理范围

- 内存紧张时，会降低分配给窗口的内存。先收缩窗口，在降低缓存。
- 当窗口处理的大小满了之后，称为窗口关闭，会「定时的探测窗口大小」。

# 拥塞控制 - 网络效率，解决丢包问题

## 慢启动
- 每次收到ACK时，发送窗口大小翻倍。
- 拥塞避免：慢启动阈值，到达了阈值时（丢包），进行快速重传，快速恢复。

## 快速重传：
- 出现原因：丢包时，发送端进行重传。所以会出现失序的数据段。
- 原理：
  - 接收端，接收到一个失序数据段时，立即发送所期待的ACK缺口序列号。
  - 发送端，当收到3个重复的ACK段时，不在等待定时器触发，直接基于快速重传机制，重发报文段。此时，不需要进入慢启动，会将速度降下一半，并进入快速回复。

## 选择性确认算法
- 会收到重复的ACK，但是之后的几个SYN已经发送了。
- 原理：重传时，将已经发送的序列号一起发送给服务端。

## 测量带宽的拥塞控制算法