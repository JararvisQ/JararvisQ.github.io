![](/image/d89d1b4759fcadca1faf5e7861a7706.png)

# 设计目的
- 身份验证
- 保密性
  - handshake 握手协议
    - 验证通讯双方身份
    - 交换加解密套件
    - 协商加密参数
- 完整性

# 对称加密 - 带锁的箱子，相同的钥匙「AES算法」
- 明文 + AES加密函数 + 密钥 = 密文c
- XOR异或运算，需要长度相等
- 将明文分成多个等长的block模块。每个模块进行解密，当最后一个明文长度不足时需要填充。 「填充padding」

## 加密模式
- 分组工作模式（ECB模式）
  - 允许使用同一个分组密码密钥对多于一块的数据进行加密，保证其安全性。
  - 问题：无法隐藏数据特征
- CBC模式
  - 每个明文和前一块密文进行异或
  - 问题：加密过程串行化
- CTR
  - 递增的加密计数器产生密钥流
  - 问题:不能提供密文消息完整性校验
- MAC：密钥完整性校验（证书验证原理）

# 非对称加密 - RSA算法 - 对一个大数做因式分解困难

## 应用：
- ## 数字签名
  - 基于私钥加密，只能使用公钥解密，起到身份认证的作用
  - 公钥管理体系：Public key infrastructure(PKI)公钥基础设施
    - CA数字证书颁发机构颁发数字证书

  - 数字证书验证: 信息 + hash + CA私钥加密 === 信息 + hash + CA公钥解密
- ## DH密钥交换 - TLS协商算法加密
  - 双方没有任何预先信息的条件下通过不安全信道创建一个密钥
  - 中间人伪装成各方并发送请求，解决：PKI机构CA私钥签名

- ## ECDH密钥交换协议
  - 比DH计算速度更快，同等安全下密钥更短。

# TLS1.3

## TLS1.2
- 功能：验证身份，达成安全套件共识，传递密钥，加密通讯
- 问题：512位以下的RSA加密套件容易破解。

## 1.3握手过程
1. 客户端发送public key给到服务端，并且带上五种加密套件的公钥发给服务器，服务器选择完，并返回相应的public key。
2. 双方可以用各自的private key + 另一方的public key进行加密传输。

- 将2RTT -> 1RTT


# TLS提供的减少握手RTT时间
- session缓存。握手后会生成一个有时间限制的sessionID，存储的是加密密钥。在下一次握手时直接取到id的value直接进行使用，不用重新生成DH密钥或者ECDH密钥。

## 如何多个服务器中共享sessionID，并且会有内存消耗
- 优点：session ticket。不需要暂用内存进行存储ID；并且是整个服务器集群中唯一存在的密码。
- 同样是第一次后返回给客户端，客户端收到后下一次带上给服务端。只有集群内的服务器才知道如何解密，解密完即可获取加密密钥。

# TLS的0RTT握手和重放攻击
- 有了缓存，第二次之后直接发送数据。服务端也返回数据。
- 问题：如果中间人将发送的报文保存下来，那也可以伪装成相应的客户端。
- 解决：设定合理的截至时间。

# 量子通讯？ - 量子密钥分发
- TLS协议的安全性限制于当下计算机的运行速度。
- TLS:双方在「身份验证」基础上，协商出「一次性的随机」的密钥。
  - PKI公钥基础设施 - 身份验证
  - TLS中间件生成一次性的，随机的密钥 - 一次性
  - DH协议非对称加密协商出密钥 - 随机
- 分组：对称加密算法

- 原理：任何对系统的测量都会对系统有干扰，则通讯双方会有察觉

## BB84协议