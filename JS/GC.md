# V8垃圾回收机制

- JS内存限制大致为64位1.4GB内存。

- JS的数据是存储在栈和堆中的：

  - 调用栈内内存的回收：

    - 在调用栈中有一个「记录当前执行状态的指针ESP」，ESP指向的位置就是正在执行的函数。当一个函数执行完毕后，该指针进行下移操作，当再调用另一个函数时，这块内存会被直接「覆盖」。

  - 堆中数据如何回收：

    - 代际假说。
      1. 大部分对象在内存存在的时间很短。
      2. 不死的对象会活得更久。

    - 思路：
      1. 标记活动和非活动对象。
      2. 回收非活动对象，清理内存。
      3. 内存碎片整理。

    - 老生代：存放生存时间久的对象。主垃圾回收器。

      - 标记 - 清除策略。从根元素开始，能到达的为活动对象，没有到达的为垃圾数据，进行标记。然后不是对垃圾进行清理，而是对所有存活对象向一端移动，然后再清理掉垃圾内存。

    - 新生代：存放生存时间少的对象。1 ~ 8 MB容量。副垃圾回收器。
      - Scavenge算法。划分为两个区域，其中一半为空闲区域。当对象区域快被写满时，需要执行一次垃圾回收工作。首先对对象区域内没有标记的存活对象复制到空闲区域，同时进行有序的排列。之后清理对象区域内的内存。之后两者角色翻转。

      - 晋升策略。如果经过两次垃圾回收还存活的对象，会被移动到「老生区」。

  - 全停顿。JS为单线程语言。触发垃圾回收时不能执行其他的机制，所以会阻碍主线程的执行。
    - 增量标记算法。「将多个垃圾回收任务分成很多小任务，由于时间较短，可以穿插在其他的JS任务中间执行。」