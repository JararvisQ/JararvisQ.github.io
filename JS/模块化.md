# 模块化
- node诞生之后，出现了多种复杂场景，为了提高代码复用率。
- 只有导出的变量才能被外部使用，不影响外部的作用域。

# 演变过程
## 1. 全局function。
- 将不同功能封装成不同的全局函数。
- 问题：命名污染，数据不安全，模块成员看不出直接关系。
## 2. namespace
- 对象的简单封装，减少了全局变量，解决命名冲突。
- 问题：数据不安全。
## 3. IIFE模式
- 匿名函数自调用。将数据和方法封装到一个函数内部，通过window属性暴露出来。数据私有化，只能拿到暴露的方法。
- 问题：如果依赖另一个模块。
```JS
(function(window) {
  // ...
  //暴露行为
  window.myModule = { foo, bar } //ES6写法
})(window)
```
## 4. IIFE增强：引入依赖
- 主要模式。
```JS
(function(window, $) {
  // ...
  //暴露行为
  window.myModule = { foo, bar } //ES6写法
})(window, jQuery)
```

# CommonJS
- 原理：对代码进行解析，整理出代码中的所有模块依赖关系，相关的模块代码都打包在一起，形成一个完整的JS文件。服务器端加载运行是「同步加载」。浏览器端需要编译打包。
- 特点：
  1. 不会影响全局作用域；
  2. 缓存运行结果，第二次之后直接读取缓存结果，想要再次运行必须清除缓存。
  3. 按代码中的顺序加载。
```JS
// 暴露模块
module.exports = value
exports.xxx = value // module.exports.xxx

// 引入
require(xxx) // 读入并执行一个JS文件，返回模块的的exports，如果没有则报错
```
- 加载：模块和脚本导出的是同一个引用，外面也可以改变模块导出的内容。

# AMD规范
- 异步加载，依赖前置。
- 加载完依赖后立即执行依赖模块，依赖加载成功后执行回调
```JS
// 定义
define(function() {
  return module
})
// 有依赖的模块
define(['module1', 'module2'], function(m1, m2) {
  return module
})
// 引入
require(['module1', 'module2'], function(m1, m2){
  //  使用m1/m2
})
```
- RequireJS提供define，遵循规范好处：
1. 执行顺序不会出错。
2. 不会影响全局环境。

# CMD规范
- 模块异步，延迟执行，就近依赖，先加载所有依赖模块，运行时才执行require内容，按顺序执行。
```JS
// 没有依赖的模块
define(function(require, exports, module) {
  export.xxx = value
  module.exports = value
})
// 有依赖
define(function(require, exports, module) {
  // 引入依赖模块
  var module1 = require('./module1')
  // 引入异步依赖
  require.async('./module2', function(m3) {

  })
  // 暴露模块
  exports.xxx = value
})

// 引入模块
define(function(require) {
  var m1 = require('./module1')
  // ...
})
```

# ES6模块化
- ESM的对外接口只是一种静态定义，为编译时加载，遇到模块加载命令import，就会生成一个只读引用。等脚本真正执行时，再根据这个只读引用，到被加载的那个模块内取值。
```JS
// 导出
export const value = 1
// 默认导出
export default value
// 导入
import { value } from './module1.js'
```

# ESM与commonJS的差异：
## ESM：
  - 值引用，会修改里面的值，只读
  - 模块里变量绑定所在的模块
  - 在代码静态解析阶段就会生成
## CJS：是在「加载时执行」。
  - 值拷贝。
  - 可以缓存值，修改值
  - 输出的是模块的运行结果

## 对于循环依赖
- CJS， 一旦出现了某个模块被循环加载，「只输出已经执行的部分，未执行的部分不会输出」
- ESM， 不需要关心是否发生循环依赖，只是生成一个指向被加载模块的引用。「需要开发者保证取值时能取到值」

