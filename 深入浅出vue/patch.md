# [虚拟DOM](./性能优化/虚拟DOM.md)

- 模板 -> 渲染函数 -> - vnode -- patch --> oldVnode -> 视图

## patch - 修改DOM节点，不只是找出VNode之间的差异。
- 针对两个节点的差异，并针对不同的节点进行更新。
## 1. 主要工作：
1. 新增节点
   - 只有因状态改变而新增的节点，在DOM中并不存在时，需要创建一个新的DOM节点。（例如：首次渲染）
   - 当新旧节点完全不是同一个节点时，则新增一个节点，用他去替换oldNode中所对应的真实DOM节点。
2. 删除节点
   - VNode中不存在的节点都属于废弃的节点。
   - 替换将创建的DOM节点，插入到oldNode的旁边，然后将旧节点删除。
3. 更新节点
   - 节点中一部分不同。

## 2. 一个元素从创建到渲染的过程
- 只有三种类型的节点会被创建并插入到DOM中：元素节点，注释节点，文本节点。
- 调用当前环境下的appendChild，并将其子节点也递归创建出来插入到当前的节点下面。
- 过程：创建节点 -> 创建元素节点 -> 创建子节点 -> 插入到parentNode中。
- 文本节点和注释节点，需要先判断是哪个，然后再调用createComment或者createTextNode。

## 3. 一个元素如何在视图中删除
- 将其startIdx到endIdx的节点删除。
- 之所以不用parent.removeChild，是因为考虑到「跨平台渲染」。

# PS：跨平台操作
- 之所以框架的组件模型，可以为IOS或者android编写原生渲染应用。其实就是再设计框架时候，「将框架的渲染机制和DOM解耦」，也就是将更新DOM节点的操作进行封装。再其他平台再将节点操作的API和框架运行时对接一下，就可以实现原生渲染的目的了。

# 4. 更新节点

## 4.1 静态节点
- 死数据。状态改变不会影响到。
## 4.2 新虚拟节点有文本属性 - text
- 如果新虚拟节点里有文本节点，并且和旧的文本属性不同，直接设置成新虚拟节点的文本。

## 4.3 无文本节点
- 存在两种情况：
   - 有children：
      - 旧节点有children：新旧对比。更新子节点。
      - 旧节点无children：
         - 是否有文本，有文本将其清空，在将children创建成「真实的DOM插入到视图的DOM」中。
   - 无children：（说明新节点是空节点）
      - 旧节点里有什么删什么。

![](/image/7cb1faab70cb1be4a387c5696a7d57c.jpg)

## 5. 更新子节点
- 分类：更新节点，新增节点，删除节点，移动节点。
- 通过循环newChildren，在oldchildren尽可能找到相同的子节点。

### 5.1 新增节点 - 旧节点里没有找到相同的节点
- 将新增节点插入到oldchildren未处理的节点前面。

### 5.2 更新节点 - 节点同时存在新旧children中

### 5.3 移动节点 - new 和 old的节点是同一个节点，但位置不同
- Node.insertBefore移动到所有未处理的节点前面。
- 如何分辨节点处理过，未处理过？

### 5.4 删除节点 - new 不存在 old 存在
- new循环结束后，old没被处理过的，就是需要被删除的节点，删除new不存在的节点。