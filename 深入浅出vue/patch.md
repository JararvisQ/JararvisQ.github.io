# [虚拟DOM](./性能优化/虚拟DOM.md)

- 模板 -> 渲染函数 -> - vnode -- patch --> oldVnode -> 视图

## patch - 修改DOM节点，不只是找出VNode之间的差异。
- 针对两个节点的差异，并针对不同的节点进行更新。
## 1. 主要工作：
1. 新增节点
   - 只有因状态改变而新增的节点，在DOM中并不存在时，需要创建一个新的DOM节点。（例如：首次渲染）
   - 当新旧节点完全不是同一个节点时，则新增一个节点，用他去替换oldNode中所对应的真实DOM节点。
2. 删除节点
   - VNode中不存在的节点都属于废弃的节点。
   - 替换将创建的DOM节点，插入到oldNode的旁边，然后将旧节点删除。
3. 更新节点
   - 节点中一部分不同。

## 2. 一个元素从创建到渲染的过程
- 只有三种类型的节点会被「创建并插入到DOM中」：元素节点，注释节点，文本节点。
- 调用当前环境下的appendChild，并将其「子节点也递归创建」出来插入到当前的节点下面。
- 过程：创建节点 -> 创建元素节点 -> 创建子节点 -> 插入到parentNode中。
- 文本节点和注释节点，需要先判断是哪个，然后再调用createComment或者createTextNode。

## 3. 一个元素如何在视图中删除
- 将其startIdx到endIdx的节点删除。
- 之所以不用parent.removeChild，是因为考虑到「跨平台渲染」。

# PS：跨平台操作
- 之所以框架的组件模型，可以为IOS或者android编写原生渲染应用。其实就是再设计框架时候，「将框架的渲染机制和DOM解耦」，也就是将更新DOM节点的操作进行封装。再其他平台再将节点操作的API和框架运行时对接一下，就可以实现原生渲染的目的了。

# 4. 更新节点
- 两个节点是同一个节点。
## 4.1 静态节点
- 死数据。状态改变不会影响到。
## 4.2 新虚拟节点有文本属性 - text属性
- 如果新虚拟节点里有文本节点，并且和旧的文本属性不同，直接设置成新虚拟节点的文本。

## 4.3 无文本节点
- 存在两种情况：
   - 有children：
      - 旧节点有children：新旧对比。更新子节点。
      - 旧节点无children：
         - 是否有文本，有文本将其清空，在将children创建成「真实的DOM插入到视图的DOM」中。
   - 无children：（说明新节点是空节点）
      - 旧节点里有什么删什么。

![](/image/7cb1faab70cb1be4a387c5696a7d57c.jpg)

## 5. 更新子节点 - 「新旧节点里都有子节点」
- 分类：更新节点，新增节点，删除节点，移动节点。
### 5.1 新增节点 - 旧节点里没有找到相同的节点
- 将新增节点插入到oldChildren未处理的节点前面。

### 5.2 更新节点 - 节点同时存在新旧children中

### 5.3 移动节点 - new 和 old的节点是同一个节点，但位置不同
- Node.insertBefore移动到所有「未处理的节点前面」。
- 如何分辨节点处理过，未处理过？

### 5.4 删除节点 - new 不存在 old 存在
- new循环结束后，old没被处理过的，就是需要被删除的节点，删除new不存在的节点。

## 5.5 优化策略 - 「新旧节点都是同一个节点」（快捷查找）
- newChildren和oldchildren所有的节点位置都是相同的。
- 只要通过两边往「中间遍历的方法遍历」，就能find到新旧节点列表里哪个是对应的。
- 目的：为了大程度避免循环oldChildren来查找节点。

### 查找方法 - 指的是未处理的第一个节点
1. 新前与旧前。
   - 如果找到了，直接更新节点。找不到不管。
2. 新后与旧后。
   - 同1。
3. 新后与旧前。
   - 找到了，则更新节点同时，还需将处理完的旧节点（已经处理成新的节点）移动到未处理的节点后。
4. 新前与旧后。
   - 找到了，则更新节点同时，还需将处理完的旧节点（已经处理成新的节点）移动到未处理的节点前。
5. 通过快捷查找仍旧没找到，在通过循环的方式去oldChildren查找一圈。

- 问题：由于这种问题，未处理的两边节点都被用到了，所以采用往中间遍历的方法。
- 在最后的循环时，会通过「key」和index索引建立对应关系，然后，如果存在key的话，会直接通过索引去拿到对应的节点。
- 在旧节点中找到后，会将节点设置为undefined。


# 流程
- 旧节点是否存在, 不存在直接插入视图，如果存在
- 则判断是否是同一个，不同直接插入到旧节点旁，然后删除旧的（新节点替换老节点），如果同一个
- 是否是静态节点，是的直接退出。不是
- 是否有text属性，有，和旧节点是否相同，进行替换，新增或者删除text属性，如果没有
- 是否有子节点，没有，对旧的进行清空，如果有
- 是否旧的有子节点，是否不相同，不相同则清空。如果相同
- 遍历一次新的节点。新增的加到旧节点前，不存在的旧节点删除。
- 更新子节点，两边往中间遍历，交叉对比，如果一样则移动到旧的对应位置，同前后。旧的设置为undefined。
- 找不到的话，进行更新，通过key和index建立的索引表进行遍历，进行更新操作

# 思路
- 元素可更新进行更新
- 不能更新进行移动
- 不能移动才进行新增和删除

# 如何判定节点是相同的节点
- key值
- asyncFactory 是不是异步组件，如果是则通过判断异步组件的占位符否存在 isAsyncPlaceholder
- tag值
- 其他边界条件。input等