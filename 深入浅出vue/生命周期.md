# 生命周期
- 主要阶段：初始化阶段，模板编译阶段，挂载阶段，卸载阶段。
- 为了提供注入代码的能力，提供了「生命周期」的机会。
![](https://v3.cn.vuejs.org/images/lifecycle.svg)

## 1. 初始化阶段 new Vue() ~ created
- 初始化一些属性，事件以及响应式数据，例如：props，methods，data，computed，watch，provide，inject

## 2. 模板编译阶段 created ~ beforeMount
- 将模板编译为渲染函数。
- 运行时构建版本中不会存在这个阶段。参见[vm.$mount](./实例方法，全局API原理.md)主要是：会默认实例上已经有渲染函数，如果不存在则设置一个，「为一个空节点的VNode」。

## 3. 挂载阶段 beforeMount ~ mounted
- 将实例挂载到DOM元素。
- 挂载过程中，会开启watcher来持续追踪依赖变化。触发变化时，会通知组件使用虚拟DOM重新渲染，会触发「beforeUpdate」函数，渲染完触发「update」。
- 知道组件被销毁。

## 4. 卸载阶段 调用vm.$destroy后
- 实例将自身从父组件删除。取消实例上所有依赖的追踪并且移除所有事件监听。

# 源码角度理解生命周期

## new Vue()
1. 通过initMixin方法将_init挂载到Vue构造函数的原型上。（同实例方法挂载方法）
2. _init内部原理
  ```JS
  Vue.prototype._init = function(options) {
    vm.$options = mergeOptions(
      resolveConstructorOptions(vm.constructor)
      options || {},
      vm
    )

    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    callHook(vm, 'beforeCreate')
    initInjections(vm)
    initState(vm) // props,methods,data,computed,watch
    initProvide(vm)
    callHook(vm, 'created')

    if (vm.$options.el) {
      vm.$mount(vm.$options.el) // 如果没有el元素需要用户手动挂载
    }
  }
  ```
3. callHook函数
  - vue构造函数，通过options参数得到用户设置的生命周期钩子。
  - 会合并在options过程中找出options中所有key是钩子函数的名字，并转化为数据。（多个同名钩子合并成一个）
  - 遍历列表调用函数。
  - try...catch捕获钩子函数发生的错误。并会在handleError处理完一次执行父组件的errorCaptured钩子，和全局config.errorHandler

## errorCaptured和错误处理
- 接收三个参数：错误对象，组件，来源信息。
- 返回false会阻止错误向上传播。
- 传播规则：
  - 全局config.errorHandler定义，都会发送到这。
  - 子组件handleError，会触发其父级从属链路中的多个errorCaptured钩子。会被多个错误逐个唤起。
  - errorCaptured抛出个错误，会和原本捕获的错误发送到全局。
  - false会阻止事件传播。

## 初始化实例属性
- 在「initLifecycle」中接受的VM实例，直接将属性挂载到vm上，例如：$parent，$root，$children等。
- 特别提到$root，表示当前组件的根实例，如果没有父组件，就是它自己。直接子组件的root还是父组件自身。孙组件直接沿用子组件中的$root。

## 初始化事件
- 父组件在模板中使用v-on注册的事件，添加到子组件的事件系统。
- 只有是组件标签，才会注册到子组件的事件系统中。如果是平台标签，会注册到浏览器事件中。
- 组件的事件系统，保存在vm._events中，在模版编译时，会保存在vm.$options._parentListeners中。通过子组件的$emit触发事件。
- 实现：
  - updateComponentListeners，将所有事件注册到this._event。同时，有add和remove两个方法来注册和卸载事件。
  - 如果事件名都存在，则替换成新的回调。
- normalizeEvent，将事件修饰符。

## 初始化inject
- `所有子代注入依赖`。
- inject的值可以被data，props之中用到，所以在data/props之前初始化。
- 实现：
  - 获取用户配置的inject，保存到result中。
  - `标识不转化为响应式`。
  - resolveInject，为了获得注入的内容。inject配置的key从当前组件读取内容，读取不到则读取他的父组件。父组件的实例中有_provide属性。
  - 同时支持Symbol，用Reflect.ownKeys（不获取不可枚举的属性）读取inject所有的key，如果不支持symbol则用Object.key，同时必须filter不可枚举的属性。
  - 同时处理options为函数，默认值的情况，分别时执行还有当source = false时，赋默认值。
- 如果inject是个数组？vue实例化时会将数据进行标准化，也就是会转化为Object的形式。

## 初始化状态 - initState
- 初始化props,methods,data,computed,watch。
- 初始化顺序：顺序决定了在data里可以使用props中的数据。
```JS
export function initState(vm) {
  vm._watchers = [] // 保存当前组件所有的watcher实例，无论是vm.$watch还是watch选项都是添加到这
  const opts = vm.$options
  opts.props && initProps(vm, opts.props)
  opts.methods && initMethods(vm, opts.methods)
  if (opts.data) {
    initData(vm)
  } else {
    observe(vm._data = {}, true)
  }
  opts.computed && initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}
```
## 1. 初始化props
- 子组件选项从`父组件提供的数据`筛选出来，添加到子组件上下文中。
- PS：在渲染函数执行中，如果节点是组件节点，会在DOM渲染过程中，将「子组件实例化」，会将模板解析的标签属性解析出的数据当作参数传递给子组件。
- 实现：
  1. 规格化props。名称驼峰化，数组规格化为对象。
  2. 初始化props。规格化后的props从父组件传入的数据（或者new实例时传入的propsData），通过options筛选出需要的数据，保存在vm._props中。
    - 同时，会有一个`keys指向vm.$options._propsKeys，缓存props对象中的key，方便将来遍历更新时遍历`。
    - 非根节点的props，需`转化为响应式`。
    - 需要处理boolean的情况。
    ```html
    <!-- 父组件是否有传这个属性，如果没有需要将value设置为false -->
    <Component
      :isVisible="false" />
    ```
  3. 在`vm设置一个代理`。通过vm.x访问到vm._props.x目的。

## 2. 初始化methods
- 只需循环选项中的methods对象，将每个属性依次挂载到vm上的methods
- 实现：
  1. 检验方法是否合法。是否有「$，_」开头。
  2. 判断key是否存在，如果存在将方法通过bind改写this，在复制到vm[key]。

## 3. 初始化data
- 设置到vm._data，并设置代理。
- 在将data转化为响应式数据。
- 实现：
  1. option如果是函数需要执行函数，并将返回值赋值到data和vm._data。
  2. 只有props中不存在key时，才会代理到实例。并不能以「$，_」开头。如果methods key有重复，仍然会代理到实例。

### PS proxy
```JS
function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key]
  }
  sharedPropertyDefinition.set = function proxySetter() {
    this[sourceKey][key] = val
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
```

## 4. 初始化computed
- 定义在`vm上一个特殊的getter方法`。「实现了缓存还有收集依赖的功能」
- 在数据变化了后，会将watcher的dirty属性设置为true，在下一次读取计算属性时，会向watcher发送通知，执行render函数时重新渲染。如果为false，说明数据没变，返回原来的值。不触发渲染。
- 实现：
  1. 会在vm上新增_computedWatchers属性，用来保存所有计算属性的watcher实例。
  2. 如果和props同名会报警告，如果和methods同名，会默默失效。
  3. 重新渲染的变化：
    - 在2.5.2版本前，计算属性函数中当有一个状态改变了，组件的watcher会得到变化，无论值变化与否都会得到通知，之后会执行重新渲染操作。
    - 2.5.17之后，当值的状态变了后，计算属性的watcher会得到通知，计算一次计算属性的值，如果不同，在通知组件的watcher进行重新渲染。

## 5. 初始化watch
- firefox上有一个Object.prototype.watch。如果不是，则循环watch选项，将对象每一项`依次调用vm.$watch`来观察值的变化。
- 如果是数组，需要对数组里的每一个元素都执行createWatcher来创建watcher。

## 6. 初始化provide
- 添加到vm._provided。