# 模板编译 - 生成渲染函数

## 模板编译在渲染过程的位置
`template` -> 模板编译 -> 渲染函数 -> VNode -> 用户界面

## 生成渲染函数
- 将模板解析成 `AST` 。
- 遍历 `AST` 标记静态节点。
- 使用 `AST` 生成渲染函数。

## 对应着三大块内容
- 解析器。过滤器解析器，文本解析器（解析例如：`Hello {{name}}`），HTML解析器（在其结束解析一个标签时，都会触发「钩子」，然后将相关信息传出「生成一个对应的 `AST` 」）。
- 优化器。遍历 `AST` ,检测出静态子树，然后打tag。
- 代码生成器。将AST转化成渲染函数。
```JS
const code = with(this){ return 'Jarar' }
new Function(code)
```

# 解析器
类似浏览器 `HTML解析`（Vue多出了个触发钩子，浏览器会判断是否是安全的HTML tag）

## 内部组成
HTML解析器，文本解析器，过滤器解析器。

## 1. HTML解析器

- 在解析过程中，不断触发 `start，end，chars，comment` 钩子。
- 钩子函数接收三个参数，分别是：tag，attrs，unary（是否闭合）。
- 用栈进行维护，取出父级。

### 流程
模板是以一小段一小段截取并解析的，需要通过一个循环进行截取直到结束。
1. 先判断是否是正常元素的逻辑。如果是正常元素则继续，如果是 `script，style，textarea` 需要按文本形式截取并触发 `chars钩子`。如果是正常元素继续。
2. 解析是开始标签，结束标签，或者是文本。可能出现的清空如下：
  - 文本。唯一一个不是「<」开头的。
  - 注释。
  - 条件注释。
  - DOCTYPE.
  - 结束标签。
  - 开始标签。
3. 按照不同的类型进行处理。

## 2. 文本解析器

- 带文本的变量需要将变量替换成变量的值，在文本解析器中，构建一个带变量的文本类型到 `AST` ，并添加到 `父节点 children` 中。（调用 `toString` 方法）。
- 最终 `AST` 转化成代码字符串并「放在 `with` 中执行」。(类似`webpack require`)

# 优化器 (patch 静态节点)
- 在 `AST` 中找出静态子节点并打赏标记 `static，staticRoot` 。
- 在重新渲染时，不会生产新的子节点树，而是克隆已存在的静态子树。

## 作用
- 每次重新渲染时，不需要为静态子树创建节点；
- 不需要在 `vDOM` 中打补丁。

## 流程：
- 递归的先判断根节点是否是静态根节点，再用相同的方式处理子节点。
- 如果遇到根节点下没有或者只有一个文本节点，不会将他标记为静态根节点。

# 代码生成器
- 其实就是字符串的拼接过程。
- 递归的遍历 `AST` 生成字符串，最先生成根节点，再是子节点。
- 分别有 `元素节点_c`，`文本节点_v`，`注释节点_e`。
- 最后将字符串拼接好在 `with` 中返回给调用者。