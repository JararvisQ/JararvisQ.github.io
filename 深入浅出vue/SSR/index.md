
# 解决问题
- CSR (Client Side Rendering) 下，访问页面需要有很长的JS加载时间，在客户端网络差的情况下，更明显。
- 搜索引擎的爬虫抓取不到 body 上的页面数据，对于SEO很不利。

# 策略
- 用户范文页面时，把首屏渲染的 HTML 内容写入到 body。

# 同构应用
![](/image/9d45ebf1732409756de57abce2792bc.png)
- 原因：我们既需要提供服务器渲染的首屏内容，又需要 CSR 带来的优秀交互体验。
- 怎么做：
  - 将客户端代码拆成 component + store + router；并设置两个入口，分别是客户端和服务端入口。（通过打包配置）
  - 最终`首次访问页面时通过服务端入口进入`，显示服务器渲染的结果，然后`用户在后续的操作中由客户端接管`，通过 vue-router 来提高页面跳转的交互体验

- 缺陷：需要在服务器上部署多一个Node环境，实际上是把客户端的渲染组件计算迁移到了服务端。大并发量下可能会加重服务器负担，所以一般都有`降级渲染`。

# SSR 架构的问题 - 静态网站生成（Static Site Generation，SSG）
- 原理：将页面直接渲染成静态页面显示。（针对页面中变动频率不高的页面）
- PS: SSR框架Nuxt，这一部分页面变化频率低，我们静态化之后还可以通过部署到 CDN 来进行页面加速。每次更新完，重新生成一遍即可。

# 客户端渲染（Native Side Rendering，NSR）
- 如果你的页面是`内嵌在客户端内部`的，可以借助客户端的运算能力，把 SSR 的逻辑移动到客户端进行，使用客户端渲染。`降低服务器负载`。

# 增量渲染（Incremental Site Rendering，ISR）
- 每次只生成核心重点的页面。其他的页面访问的时候先通过 CSR 的方式渲染，然后把渲染结果存储在 CDN 中。

# 边缘渲染（Edge Side Rendering，ESR）
- 把静态内容和动态的内容都以流的方式返回给用户，在 CDN 节点上返回给用户缓存静态资源，同时在 `CDN 上负责发起动态内容的请求`。
- 浏览器里跑 node 的 webContainer 技术。可能可以将Node服务部署在CDN节点上，从而实现ESR。