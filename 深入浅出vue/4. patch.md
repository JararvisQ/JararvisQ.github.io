# 前置知识

## [虚拟DOM](../性能优化/虚拟DOM.md)
模板 -> 渲染函数 -> vnode -> patch -> oldVnode -> 视图

## patch
- 查找两个节点的差异，并针对不同的节点进行更新。
- 只有三种类型的节点会被「创建并插入到DOM中」：`元素节点，注释节点，文本节点`。

## patch 主要工作

1. 新增节点
   - 只有因状态改变而新增的节点，在 DOM 中并不存在时，需要创建一个新的 DOM 节点。（例如：首次渲染）
   - 当新旧节点完全 `不是同一个节点` 时，则新增一个节点，用他去替换 `oldNode` 中所对应的真实 `DOM` 节点。

2. 删除节点
   - `VNode` 中不存在的节点都属于废弃的节点。
   - 替换将创建的 DOM 节点，插入到 `oldNode` 的旁边，然后将旧节点删除。
   - 如何删除：
      - 将其 `startIdx` 到 `endIdx` 的节点删除。
      - 之所以不用 `parent.removeChild` ，是因为考虑到「[跨平台渲染](#跨平台操作)」。

3. 更新节点
   - 节点中一部分不同。

## 一个元素从创建到渲染的过程

- 调用当前环境下的 `appendChild` ，并将其「子节点也递归创建」出来插入到当前的节点下面。(创建节点 -> 创建元素节点 -> 创建子节点 -> 插入到 `parentNode` 中)
- 文本节点和注释节点，需要先判断是哪个，然后再调用 `createComment` 或者 `createTextNode` 。

## 跨平台操作
之所以框架的组件模型，可以为 `IOS` 或者 `android` 编写原生渲染应用。其实就是再设计框架时候，`将框架的渲染机制和DOM解耦` ，也就是将更新 DOM 节点 的操作进行封装。再其他平台再将节点操作的 API 和框架运行时对接一下，就可以实现原生渲染的目的了。

# 更新节点
两个节点是同一个节点。

## 1. 静态节点
死数据。状态改变不会影响到。

## 2. 新虚拟节点有文本属性
如果新虚拟节点里有 `文本节点` ，并且和旧的文本属性不同，直接设置成新虚拟节点的文本。

## 3. 新是否有父子节点
- 新节点有 Children：
   - 旧节点有 Children：新旧对比。[更新子节点](##4.更新子节点)。
   - 旧节点无 Children：
      - 是否有文本，有文本将其清空，在将 `Children` 创建成 `真实的DOM插入到视图的DOM` 中。
- 新节点无 Children：
   - 旧节点里有什么删什么。

![](/image/7cb1faab70cb1be4a387c5696a7d57c.jpg)

# 4. 更新子节点
新旧节点里都有子节点

## 新增节点
旧节点里没有找到相同的节点
- 将新增节点插入到 `oldChildren` 未处理的节点前面。

## 删除节点
`new` 不存在 `old` 存在
- `new节点列表` 循环结束后，`old节点列表` 中没被处理过的，就是需要被删除的节点，删除new不存在的节点。

## 更新节点
节点同时存在新旧 `children` 中

## 移动节点
`new` 和 `old` 的节点是同一个节点，但位置不同
- `Node.insertBefore` 移动到所有「未处理的节点前面」。
   - 如何分辨节点处理过，未处理过？（循环顺序即可）
   - 为何移动到节点前面？（处理节点时，顺序处理，因此左边都是处理过的节点，从而只需移动到 `未处理节点` 的前面即可）

## 优化策略（快捷查找）

- 原因：并不是所有的节点都需要移动，只需找到需要移动的节点即可，不需要遍历全部节点。
- `newChildren` 和 `oldChildren` 所有的节点位置都是相同的。
- 只要通过两边往「中间遍历的方法遍历」，就能find到新旧节点列表里哪个是对应的。
- 目的：为了大程度避免循环 `oldChildren` 来查找节点。

## 查找方法

1. 新前与旧前。
   - 如果找到了，直接更新节点。找不到不管。
2. 新后与旧后。
   - 同1。
3. 新后与旧前。
   - 找到了，则更新节点同时，还需将处理完的旧节点（已经处理成新的节点）移动到未处理的节点后。
4. 新前与旧后。
   - 找到了，则更新节点同时，还需将处理完的旧节点（已经处理成新的节点）移动到未处理的节点前。
5. 通过快捷查找仍旧没找到，再通过 `循环` 的方式去 `oldChildren` 查找一圈。

## 问题
由于这种问题，未处理的两边节点都被用到了，所以采用往中间遍历的方法。
- 在最后的循环时，会通过 `key` 和 `index` 索引建立对应关系，然后，如果存在 `key` 的话，会直接通过索引去拿到对应的节点。
- 在旧节点中找到后，会将节点设置为 `undefined` 。


# 流程

- 旧节点是否存在, 不存在直接插入视图，如果存在，
- 是否是 `同一个节点` ，不同直接插入到旧节点旁，然后删除旧的（新节点替换老节点）,如不存在；
- 是否是 `静态节点` ，是的直接退出。
- 是否有 `text属性` ，有，和旧节点是否相同，进行替换，新增或者删除 `text属性` ;
- 是否有 `子节点` ，没有，对旧的进行清空，如果有
- 是否 `旧的有子节点` ，是否不相同，不相同则清空。如果相同
- `遍历` 一次新的节点。进行 [快捷查找](#优化策略快捷查找) ，两边往中间遍历，交叉对比，如果一样则移动到 `新节点的对应位置` ，同前后。旧的设置为 `undefined` 。如果找不到；
- 通过 `key` 和 `index` 建立的索引表进行遍历，找到了即进行更新操作，如果找不到；
- 再去旧节点里进行查找；

# 思路
- 元素可更新进行更新
- 不能更新进行移动
- 不能移动才进行新增和删除

# 如何判定节点是相同的节点
- key值
- asyncFactory 是不是异步组件，如果是则通过判断异步组件的占位符否存在 isAsyncPlaceholder
- tag值
- 其他边界条件。input等